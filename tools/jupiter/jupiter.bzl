# Copyright 2018 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
load("@io_bazel_rules_kotlin//kotlin:kotlin.bzl", _kt_jvm_test = "kt_jvm_test")

_SUITE_CLASS_HEADER = """
// This suite class is generated by the junit_jupiter macro.
import org.junit.runner.RunWith;
import org.junit.platform.runner.JUnitPlatform;
import org.junit.platform.suite.api.UseTechnicalNames;
import org.junit.platform.suite.api.SelectPackages;
import org.junit.platform.suite.api.SelectClasses;
import org.junit.platform.suite.api.ExcludeTags;
"""

_KOTLIN_DIALECT = struct(
    ann_arr_lbrace = "",
    ann_arr_rbrace = "",
    cls_sep = "::",
    file_ext = "kt",
    header = _SUITE_CLASS_HEADER,
    test_deps = depset([
        "//tools/jupiter:jupiter_api",
        "@com_github_jetbrains_kotlin//:kotlin-test",
        "@com_github_jetbrains_kotlin//:kotlin-test-junit5",
    ]),
    rule = _kt_jvm_test,
)

_JAVA_DIALECT = struct(
    ann_arr_lbrace = "{",
    ann_arr_rbrace = "}",
    cls_sep = ".",
    file_ext = "java",
    header = _SUITE_CLASS_HEADER,
    test_deps = depset(["//tools/jupiter:jupiter_api"]),
    rule = native.java_test,
)

def _mk_default_annotations(d):
    return ("""@RunWith(JUnitPlatform{cls_sep}class)
@UseTechnicalNames
""".format(cls_sep = d.cls_sep))

def _mk_list_ann(dialect, name, lst):
    """Generate an annotation token containing the strings in lst. returns the empty string if the list is empty"""
    ret = ""
    if len(lst) > 0:
        ret = "\n@%s(%s\n%s\n%s)" % (
            name,
            dialect.ann_arr_lbrace,
            ",\n".join(lst),
            dialect.ann_arr_rbrace,
        )
    return ret

def _mk_class(c, sep):
    parts = c.split(".")
    cn = parts[len(parts) - 1]
    if not cn.endswith("Test"):
        fail("test class must end with Test")
    return ("%s%sclass" % (cn, sep))

def _gen_suite_class(name, dialect, test_classes, test_packages, exclude_tags):
    if (len(test_classes) + len(test_packages)) == 0:
        fail("must provided at least a single test class or package")
    suite_class_name = "TestSuite%s" % name
    suite_class_file = "%s.%s" % (suite_class_name, dialect.file_ext)
    imports = "\n".join(["import %s;" % c for c in test_classes]) + "\n\n"

    annotations = (
        _mk_default_annotations(dialect) +
        _mk_list_ann(dialect, "SelectClasses", ["    %s" % _mk_class(c, dialect.cls_sep) for c in test_classes]) +
        _mk_list_ann(dialect, "SelectPackages", ["    \"%s\"" % p for p in test_packages]) +
        _mk_list_ann(dialect, "ExcludeTags", ["    \"%s\"" % p for p in exclude_tags])
    )

    clz = """public class %s {}""" % suite_class_name

    native.genrule(
        name = "%s_suite_gen" % name,
        outs = [suite_class_file],
        cmd = """
cat <<EOF >> $@
%s
EOF
""" % (
            dialect.header +
            imports +
            annotations +
            clz
        ),
    )
    return (suite_class_name, suite_class_file)

def jupiter_test(
        # These parameters are standard rule parameters and are forwarded to the underlying test rules. They are enumerated
        # for discovery by intellij.
        name,
        srcs = [],
        deps = [],
        friends = [],
        runtime_deps = [],
        jvm_flags = [],
        visibility = ["//visibility:private"],
        resources = [],
        resources_strip_prefix = None,
        resource_jars = [],
        tags = [],
        data = [],
        # These parameters become annotations on the generated suite class.
        exclude_tags = [],
        select_classes = [],
        select_packages = [],
        **kwargs):
    """Generate a suite class and delegates to Bazel's junit4 support to run it. Handles Kotlin, Java and mixed.

    This macro is appropriate for idiomatic bazel testing patterns or for traditional multi file test suites. By default
    the Jupiter engine is provided on the runtime classpath.

    Notes:
      * Mixed mode is ok for multi file tests. But it should be avoided for simple tests as the compilation phase is
        slower.
      * `@UseTechnicalNames` is set on the suite class by default as the intellij plugin needs this.
      * The test classes must end with "Test" or they will be ignored."""
    dialect = _JAVA_DIALECT
    dialect_args = kwargs

    # Look for a single kotlin file and switch to the kotlin dialect if found.
    for src in srcs:
        if src.endswith(".kt"):
            dialect = _KOTLIN_DIALECT
            dialect_args["friends"] = friends
            break
    suite_class, suite_class_file = _gen_suite_class(
        name,
        dialect,
        select_classes,
        select_packages,
        exclude_tags,
    )
    dialect.rule(
        name = name,
        jvm_flags = jvm_flags,
        data = data,
        test_class = suite_class,
        srcs = [suite_class_file] + srcs,
        tags = tags,
        resource_jars = resource_jars,
        deps = (dialect.test_deps + deps).to_list(),
        runtime_deps = runtime_deps,
        resources = resources,
        resource_strip_prefix = resources_strip_prefix,
        visibility = visibility,
        **dialect_args
    )
